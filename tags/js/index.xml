<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JS on Loner Bytes</title>
    <link>https://Cyber-Aju.github.io/Blog/tags/js/</link>
    <description>Recent content in JS on Loner Bytes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://Cyber-Aju.github.io/Blog/tags/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learnings of the Day 14/12</title>
      <link>https://Cyber-Aju.github.io/Blog/posts/learning-of-the-day-141223/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Cyber-Aju.github.io/Blog/posts/learning-of-the-day-141223/</guid>
      <description>##JavaScript:
Day 3: Solving in 3 Different Ways Leetcode
From the question, we need to create three functions: increment(), decrement(), and reset(). Let&amp;rsquo;s explore three different ways to implement these functions.
1. Using Traditional Function var createCounter = function(init) { let presentCount = init; function increment() { return ++presentCount; } function decrement() { return --presentCount; } function reset() { return (presentCount = init); } return { increment, decrement, reset }; }; Time and Space Complexity: O(1)</description>
    </item>
    
    <item>
      <title>Learnings of the Day 12/12</title>
      <link>https://Cyber-Aju.github.io/Blog/posts/learining-of-the-day-121223/</link>
      <pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Cyber-Aju.github.io/Blog/posts/learining-of-the-day-121223/</guid>
      <description>1. Problem: Can Make Arithmetic Progression From Sequence Leetcode
Original Code: class Solution { public: bool canMakeArithmeticProgression(vector&amp;lt;int&amp;gt;&amp;amp; arr) { for(int i=0;i&amp;lt;arr.size();i++) { int z=arr[0]-arr[1]; if(z!=(arr[i]-arr[i+1])) { return false; } } return true; } }; Modifications: class Solution { public: bool canMakeArithmeticProgression(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(),arr.end()); int z=arr[1]-arr[0]; for(int i=0;i&amp;lt;(arr.size()-1);i++) { if(z!=(arr[i+1]-arr[i])) { return false; } } return true; } }; caused of &amp;lsquo;outbound errors&amp;rsquo;.
Complexity: Time Complexity: O(n) Space Complexity: O(1) Challenges Faced: Ensuring correct handling of edge cases and optimizing the code for efficiency and Outbounds Error Learnings: Importance of not always relying on sorting and exploring alternative approaches.</description>
    </item>
    
  </channel>
</rss>
