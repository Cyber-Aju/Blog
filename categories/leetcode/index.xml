<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leetcode on The Lone Coder Aju Blog</title>
    <link>https://Cyber-Aju.github.io/demo/categories/leetcode/</link>
    <description>Recent content in leetcode on The Lone Coder Aju Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://Cyber-Aju.github.io/demo/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learnings of the Day 14/12</title>
      <link>https://Cyber-Aju.github.io/demo/posts/learning-of-the-day-141223/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Cyber-Aju.github.io/demo/posts/learning-of-the-day-141223/</guid>
      <description>##JavaScript:
Day 3: Solving in 3 Different Ways Leetcode
From the question, we need to create three functions: increment(), decrement(), and reset(). Let&amp;rsquo;s explore three different ways to implement these functions.
1. Using Traditional Function var createCounter = function(init) { let presentCount = init; function increment() { return ++presentCount; } function decrement() { return --presentCount; } function reset() { return (presentCount = init); } return { increment, decrement, reset }; }; Time and Space Complexity: O(1)</description>
    </item>
    
    <item>
      <title>Learnings of the Day 12/12</title>
      <link>https://Cyber-Aju.github.io/demo/posts/learining-of-the-day-121223/</link>
      <pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Cyber-Aju.github.io/demo/posts/learining-of-the-day-121223/</guid>
      <description>1. Problem: Can Make Arithmetic Progression From Sequence Leetcode
Original Code: class Solution { public: bool canMakeArithmeticProgression(vector&amp;lt;int&amp;gt;&amp;amp; arr) { for(int i=0;i&amp;lt;arr.size();i++) { int z=arr[0]-arr[1]; if(z!=(arr[i]-arr[i+1])) { return false; } } return true; } }; Modifications: class Solution { public: bool canMakeArithmeticProgression(vector&amp;lt;int&amp;gt;&amp;amp; arr) { sort(arr.begin(),arr.end()); int z=arr[1]-arr[0]; for(int i=0;i&amp;lt;(arr.size()-1);i++) { if(z!=(arr[i+1]-arr[i])) { return false; } } return true; } }; caused of &amp;lsquo;outbound errors&amp;rsquo;.
Complexity: Time Complexity: O(n) Space Complexity: O(1) Challenges Faced: Ensuring correct handling of edge cases and optimizing the code for efficiency and Outbounds Error Learnings: Importance of not always relying on sorting and exploring alternative approaches.</description>
    </item>
    
    <item>
      <title>Learnings of the Day 11/12</title>
      <link>https://Cyber-Aju.github.io/demo/posts/learning-of-the-day-111223/</link>
      <pubDate>Mon, 11 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Cyber-Aju.github.io/demo/posts/learning-of-the-day-111223/</guid>
      <description>Problem solving&amp;rsquo;s 1. Repeated Substring Pattern leetcode
Code: bool repeatedSubstringPattern(char s[]){ char b[50]; for(int i=0;i&amp;lt;50;i++) { b[i]=0; } for(int i=0;s[i];i++) { int k=s[i]-&amp;#39;a&amp;#39;; b[k]++; } for(int i=0;i&amp;lt;50;i++) { if(b[i]!=0) { int a=b[1]; while(b[i]==a) { return true; } } } return false; } Modifications: Then corrected version of code in a previous response.
bool repeatedSubstringPattern(char s[]) { int len = strlen(s); for (int i = 1; i &amp;lt;= len / 2; i++) { if (len % i == 0) { int numRepeats = len / i; bool isRepeated = true; for (int j = i; j &amp;lt; len; j++) { if (s[j] !</description>
    </item>
    
  </channel>
</rss>
